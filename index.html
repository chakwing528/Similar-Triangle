<!DOCTYPE html>
<html lang="zh-HK">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>相似三角形探索 - V5</title>
    <style>
        :root {
            --primary: #4F46E5;
            --bg: #F3F4F6;
            --panel-bg: #FFFFFF;
        }
        body {
            margin: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg);
            color: #333;
            display: flex;
            height: 100vh;
            overflow: hidden;
            touch-action: none;
        }
        #workspace {
            flex: 1;
            position: relative;
            background-image: radial-gradient(#d1d5db 1px, transparent 1px);
            background-size: 20px 20px;
            overflow: hidden;
            cursor: grab;
        }
        #workspace:active { cursor: grabbing; }
        
        .triangle-container {
            position: absolute;
            cursor: move;
            transform-origin: center center;
            user-select: none;
            filter: drop-shadow(2px 4px 6px rgba(0,0,0,0.1));
            transition: filter 0.2s;
            touch-action: none;
        }
        .triangle-container:hover {
            filter: drop-shadow(2px 6px 12px rgba(79, 70, 229, 0.3));
            z-index: 10;
        }

        /* V5 更新: 移除容易在 iPad 走位的 CSS transform-origin，改由 JS 寫入原生 SVG 屬性 */
        .upright-text {
            /* 保持乾淨，無 CSS transform */
        }

        #panel {
            width: 350px;
            background: var(--panel-bg);
            box-shadow: -2px 0 10px rgba(0,0,0,0.05);
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            overflow-y: auto;
            z-index: 20;
        }
        h2, h3 { margin: 0 0 10px 0; color: #111; }
        h2 { font-size: 1.3rem; border-bottom: 2px solid var(--primary); padding-bottom: 10px; }
        
        .control-group { background: #f8fafc; padding: 15px; border-radius: 8px; border: 1px solid #e2e8f0; }
        .control-group label { display: block; margin-bottom: 8px; font-weight: bold; font-size: 0.9rem;}
        input[type="range"] { width: 100%; margin-bottom: 10px; }
        
        .info-box { background: #eff6ff; padding: 15px; border-radius: 8px; border-left: 4px solid var(--primary); font-size: 0.95rem; line-height: 1.6;}
        .math-text { font-family: 'Times New Roman', Times, serif; font-size: 1.1rem; letter-spacing: 0.5px;}
        
        button {
            background: var(--primary); color: white; border: none; padding: 10px;
            border-radius: 6px; cursor: pointer; font-size: 1rem; font-weight: bold;
            transition: background 0.2s;
        }
        button:hover { background: #4338ca; }
        button:disabled { background: #9ca3af; cursor: not-allowed; }

        .radio-group label {
            display: block;
            margin-bottom: 8px;
            cursor: pointer;
        }

        #version-tag {
            position: absolute;
            bottom: 15px;
            left: 15px;
            font-size: 1.2rem;
            font-weight: bold;
            color: #9ca3af;
            z-index: 100;
            pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="workspace">
        <div id="version-tag">V5</div>
        
        <div id="tri-abc" class="triangle-container">
            <svg width="200" height="200" viewBox="0 0 200 200" style="overflow: visible;">
                <polygon points="40,40 40,140 136.5,140" fill="rgba(59, 130, 246, 0.2)" stroke="#2563EB" stroke-width="3" stroke-linejoin="round"/>
                <polyline points="40,125 55,125 55,140" fill="none" stroke="#2563EB" stroke-width="2"/>
                <path d="M 40 70 A 30 30 0 0 0 60.7 61.3" fill="none" stroke="#2563EB" stroke-width="2"/>
                <text class="upright-text" x="45" y="85" font-size="14" fill="#2563EB">44°</text>
                <text class="upright-text" x="30" y="30" font-size="18" font-family="Arial" font-weight="bold">A</text>
                <text class="upright-text" x="20" y="155" font-size="18" font-family="Arial" font-weight="bold">B</text>
                <text class="upright-text" x="145" y="155" font-size="18" font-family="Arial" font-weight="bold">C</text>
            </svg>
        </div>

        <div id="tri-efg" class="triangle-container">
            <svg width="300" height="300" viewBox="0 0 300 300" style="overflow: visible;">
                <polygon points="60,60 60,210 204.8,210" fill="rgba(16, 185, 129, 0.2)" stroke="#059669" stroke-width="3" stroke-linejoin="round"/>
                <polyline points="60,195 75,195 75,210" fill="none" stroke="#059669" stroke-width="2"/>
                <path d="M 60 100 A 40 40 0 0 0 87.6 88.4" fill="none" stroke="#059669" stroke-width="2"/>
                <text class="upright-text" x="68" y="120" font-size="16" fill="#059669">44°</text>
                <text class="upright-text" x="50" y="50" font-size="18" font-family="Arial" font-weight="bold">F</text>
                <text class="upright-text" x="40" y="225" font-size="18" font-family="Arial" font-weight="bold">E</text>
                <text class="upright-text" x="215" y="225" font-size="18" font-family="Arial" font-weight="bold">G</text>
            </svg>
        </div>
    </div>

    <div id="panel">
        <h2>圖形控制</h2>
        
        <div class="control-group">
            <label>藍色三角形 (△ABC) 旋轉: <span id="abc-rot-val">0°</span></label>
            <input type="range" id="abc-rot" min="-180" max="180" value="0">
            <label>藍色三角形 (△ABC) 縮放: <span id="abc-scale-val">1.0</span></label>
            <input type="range" id="abc-scale" min="0.3" max="2" step="0.1" value="1">
            
            <hr style="border: 0; border-top: 1px solid #e2e8f0; margin: 15px 0;">

            <label>綠色三角形 (△EFG) 旋轉: <span id="efg-rot-val">-55°</span></label>
            <input type="range" id="efg-rot" min="-180" max="180" value="-55">
            <label>綠色三角形 (△EFG) 縮放: <span id="efg-scale-val">1.0</span></label>
            <input type="range" id="efg-scale" min="0.3" max="2" step="0.1" value="1">
            
            <small style="color: #666; display: block; margin-top: 5px;">* 支援 iPad 雙指縮放與旋轉</small>
        </div>

        <button onclick="resetPosition()">重置位置與題目</button>

        <h2>幾何發現</h2>
        <div class="info-box">
            <h3>對應角</h3>
            <div class="math-text">
                ∠BAC = ∠EFG = 44°<br>
                ∠ABC = ∠FEG = 90°<br>
                ∠BCA = ∠FGE = 180° - 90° - 44° = 46°<br>
                (△內角和)
            </div>
        </div>

        <div class="info-box">
            <h3>對應邊</h3>
            <div class="math-text">
                AB 對應 FE<br>
                BC 對應 EG<br>
                AC 對應 FG
            </div>
        </div>

        <div class="info-box" style="background: #fdf2f8; border-color: #db2777;">
            <h3>結論挑戰</h3>
            <div style="margin-top: 10px;">
                <p class="math-text" style="font-weight: bold; color: #be185d; display: flex; align-items: center;">
                    ∴ △ABC ~ △ <input type="text" id="ans-letters" maxlength="3" style="width: 55px; font-size: 1.1rem; text-transform: uppercase; margin-left: 5px; padding: 2px 5px; text-align: center; border: 1px solid #db2777; border-radius: 4px;">
                </p>
                <p style="margin-top: 15px; font-size: 0.95rem; font-weight: bold;">原因:</p>
                
                <div class="radio-group" id="ans-reason-group" style="font-size: 0.95rem;">
                    <label><input type="radio" name="reason" value="AAA"> AAA</label>
                    <label><input type="radio" name="reason" value="SAS"> 兩邊成比例且夾角相等</label>
                    <label><input type="radio" name="reason" value="SSS"> 三邊成比例</label>
                </div>
                
                <button id="submit-btn" onclick="checkAnswer()" style="margin-top: 15px; width: 100%;">提交答案</button>
                <div id="feedback-msg" style="margin-top: 10px; font-weight: bold; min-height: 20px; text-align: center;"></div>
                
                <div style="margin-top: 10px; font-size: 1.2rem; font-weight: bold; color: #be185d; text-align: center; border-top: 2px dashed #fbcfe8; padding-top: 10px;">
                    分數: <span id="score-val">0</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        // State management
        const state = {
            abc: { x: 100, y: 150, rot: 0, scale: 1 },
            efg: { x: 400, y: 150, rot: -55, scale: 1 }
        };

        const elABC = document.getElementById('tri-abc');
        const elEFG = document.getElementById('tri-efg');
        const sliderAbcRot = document.getElementById('abc-rot');
        const sliderAbcScale = document.getElementById('abc-scale');
        const sliderEfgRot = document.getElementById('efg-rot');
        const sliderEfgScale = document.getElementById('efg-scale');
        
        let score = 0;
        let isQuestionAnswered = false;

        function updateTransforms() {
            // Update containers
            elABC.style.transform = `translate(${state.abc.x}px, ${state.abc.y}px) rotate(${state.abc.rot}deg) scale(${state.abc.scale})`;
            elEFG.style.transform = `translate(${state.efg.x}px, ${state.efg.y}px) rotate(${state.efg.rot}deg) scale(${state.efg.scale})`;

            // V5 修正: 使用原生 SVG 屬性解決 iPad 文字走位問題，綁定各自的 X Y 座標旋轉
            elABC.querySelectorAll('.upright-text').forEach(el => {
                const cx = el.getAttribute('x');
                const cy = el.getAttribute('y');
                el.setAttribute('transform', `rotate(${-state.abc.rot}, ${cx}, ${cy})`);
                el.style.transform = ''; // 清除舊有的 CSS 設定避免干擾
            });
            elEFG.querySelectorAll('.upright-text').forEach(el => {
                const cx = el.getAttribute('x');
                const cy = el.getAttribute('y');
                el.setAttribute('transform', `rotate(${-state.efg.rot}, ${cx}, ${cy})`);
                el.style.transform = '';
            });
        }

        function resetPosition() {
            state.abc = { x: 100, y: 150, rot: 0, scale: 1 };
            state.efg = { x: 400, y: 150, rot: -55, scale: 1 };
            
            sliderAbcRot.value = 0;
            sliderAbcScale.value = 1;
            sliderEfgRot.value = -55;
            sliderEfgScale.value = 1;
            
            document.getElementById('abc-rot-val').innerText = '0°';
            document.getElementById('abc-scale-val').innerText = '1.0';
            document.getElementById('efg-rot-val').innerText = '-55°';
            document.getElementById('efg-scale-val').innerText = '1.0';
            
            updateTransforms();

            isQuestionAnswered = false;
            document.getElementById('ans-letters').value = '';
            document.getElementById('ans-letters').disabled = false;
            
            document.querySelectorAll('input[name="reason"]').forEach(radio => {
                radio.checked = false;
                radio.disabled = false;
            });
            
            document.getElementById('submit-btn').disabled = false;
            document.getElementById('feedback-msg').innerText = '';
        }

        function checkAnswer() {
            if (isQuestionAnswered) return;

            const letters = document.getElementById('ans-letters').value.toUpperCase().trim();
            const checkedReason = document.querySelector('input[name="reason"]:checked');
            const reason = checkedReason ? checkedReason.value : '';
            const feedback = document.getElementById('feedback-msg');

            if (letters === 'FEG' && reason === 'AAA') {
                score += 10;
                document.getElementById('score-val').innerText = score;
                feedback.innerHTML = '✨ 答對了！ +10分';
                feedback.style.color = '#10b981'; 
                isQuestionAnswered = true;
                
                document.getElementById('ans-letters').disabled = true;
                document.getElementById('submit-btn').disabled = true;
                document.querySelectorAll('input[name="reason"]').forEach(radio => radio.disabled = true);
            } else {
                feedback.innerHTML = '❌ 答案或原因不正確，請再試一次！';
                feedback.style.color = '#ef4444'; 
            }
        }

        // ====== 磁吸功能 ======
        function getVertexAbs(localX, localY, centerX, centerY, stateObj) {
            const rad = stateObj.rot * Math.PI / 180;
            const dx = (localX - centerX) * stateObj.scale;
            const dy = (localY - centerY) * stateObj.scale;
            const x = stateObj.x + centerX + dx * Math.cos(rad) - dy * Math.sin(rad);
            const y = stateObj.y + centerY + dx * Math.sin(rad) + dy * Math.cos(rad);
            return { x, y };
        }

        function setVertexAbs(targetX, targetY, localX, localY, centerX, centerY, stateObj) {
            const rad = stateObj.rot * Math.PI / 180;
            const dx = (localX - centerX) * stateObj.scale;
            const dy = (localY - centerY) * stateObj.scale;
            const rotX = dx * Math.cos(rad) - dy * Math.sin(rad);
            const rotY = dx * Math.sin(rad) + dy * Math.cos(rad);
            stateObj.x = targetX - centerX - rotX;
            stateObj.y = targetY - centerY - rotY;
        }

        function checkMagneticSnap(activeId) {
            let activeState, targetState, activeEl, activeCenter, targetCenter, scaleRatio;
            
            if (activeId === 'efg') {
                activeState = state.efg; targetState = state.abc; activeEl = elEFG;
                activeCenter = 150; targetCenter = 100;
                scaleRatio = 1 / 1.5;
            } else {
                activeState = state.abc; targetState = state.efg; activeEl = elABC;
                activeCenter = 100; targetCenter = 150;
                scaleRatio = 1.5;
            }

            let snapped = false;
            
            // 1. 磁吸旋轉
            let rotA = ((activeState.rot % 360) + 360) % 360;
            let rotT = ((targetState.rot % 360) + 360) % 360;
            let rotDiff = Math.abs(rotA - rotT);
            if (rotDiff > 180) rotDiff = 360 - rotDiff;
            
            if (rotDiff < 15) {
                activeState.rot = targetState.rot;
                document.getElementById(`${activeId}-rot`).value = activeState.rot;
                document.getElementById(`${activeId}-rot-val`).innerText = Math.round(activeState.rot) + '°';
                snapped = true;
            }

            // 2. 磁吸縮放
            let targetScale = targetState.scale * scaleRatio;
            if (Math.abs(activeState.scale - targetScale) < 0.15) {
                activeState.scale = targetScale;
                document.getElementById(`${activeId}-scale`).value = targetScale;
                document.getElementById(`${activeId}-scale-val`).innerText = targetScale.toFixed(1);
                snapped = true;
            }

            // 3. 磁吸頂點
            let pairs = activeId === 'efg' 
                ? [[60, 210, 40, 140], [60, 60, 40, 40], [204.8, 210, 136.5, 140]]
                : [[40, 140, 60, 210], [40, 40, 60, 60], [136.5, 140, 204.8, 210]];

            for (let i = 0; i < pairs.length; i++) {
                const p = pairs[i];
                const vAct = getVertexAbs(p[0], p[1], activeCenter, activeCenter, activeState);
                const vTar = getVertexAbs(p[2], p[3], targetCenter, targetCenter, targetState);
                
                if (Math.hypot(vAct.x - vTar.x, vAct.y - vTar.y) < 40) {
                    setVertexAbs(vTar.x, vTar.y, p[0], p[1], activeCenter, activeCenter, activeState);
                    snapped = true;
                    break;
                }
            }

            if (snapped) {
                activeEl.style.transition = 'transform 0.25s cubic-bezier(0.175, 0.885, 0.32, 1.275)';
                updateTransforms();
                setTimeout(() => { activeEl.style.transition = 'filter 0.2s'; }, 250);
            }
        }
        // ===================================

        // Sliders events
        sliderAbcRot.addEventListener('input', (e) => { state.abc.rot = parseFloat(e.target.value); document.getElementById('abc-rot-val').innerText = Math.round(state.abc.rot) + '°'; updateTransforms(); });
        sliderAbcScale.addEventListener('input', (e) => { state.abc.scale = parseFloat(e.target.value); document.getElementById('abc-scale-val').innerText = state.abc.scale.toFixed(1); updateTransforms(); });
        sliderEfgRot.addEventListener('input', (e) => { state.efg.rot = parseFloat(e.target.value); document.getElementById('efg-rot-val').innerText = Math.round(state.efg.rot) + '°'; updateTransforms(); });
        sliderEfgScale.addEventListener('input', (e) => { state.efg.scale = parseFloat(e.target.value); document.getElementById('efg-scale-val').innerText = state.efg.scale.toFixed(1); updateTransforms(); });

        sliderAbcRot.addEventListener('change', () => checkMagneticSnap('abc'));
        sliderAbcScale.addEventListener('change', () => checkMagneticSnap('abc'));
        sliderEfgRot.addEventListener('change', () => checkMagneticSnap('efg'));
        sliderEfgScale.addEventListener('change', () => checkMagneticSnap('efg'));

        function makeDraggable(element, stateObj, idStr) {
            let isDragging = false;
            let startX, startY;

            element.addEventListener('pointerdown', (e) => {
                if (!e.isPrimary) return; 
                isDragging = true;
                startX = e.clientX - stateObj.x;
                startY = e.clientY - stateObj.y;
                element.style.zIndex = 100;
                element.setPointerCapture(e.pointerId);
            });

            element.addEventListener('pointermove', (e) => {
                if (!isDragging || !e.isPrimary) return;
                stateObj.x = e.clientX - startX;
                stateObj.y = e.clientY - startY;
                updateTransforms();
            });

            const endDrag = (e) => {
                if (!e.isPrimary) return;
                isDragging = false;
                element.style.zIndex = '';
                element.releasePointerCapture(e.pointerId);
                checkMagneticSnap(idStr);
            };

            element.addEventListener('pointerup', endDrag);
            element.addEventListener('pointercancel', endDrag);
        }

        makeDraggable(elABC, state.abc, 'abc');
        makeDraggable(elEFG, state.efg, 'efg');

        function addMultiTouch(element, stateObj, scaleSliderEl, scaleValId, rotSliderEl, rotValId, idStr) {
            let initialPinchDist = 0;
            let initialPinchAngle = 0;
            let startScale = 1;
            let startRot = 0;

            element.addEventListener('touchstart', (e) => {
                if (e.touches.length === 2) {
                    e.preventDefault();
                    let dx = e.touches[0].clientX - e.touches[1].clientX;
                    let dy = e.touches[0].clientY - e.touches[1].clientY;
                    initialPinchDist = Math.hypot(dx, dy);
                    initialPinchAngle = Math.atan2(dy, dx) * (180 / Math.PI);
                    startScale = parseFloat(stateObj.scale);
                    startRot = parseFloat(stateObj.rot);
                }
            }, { passive: false });

            element.addEventListener('touchmove', (e) => {
                if (e.touches.length === 2) {
                    e.preventDefault();
                    let dx = e.touches[0].clientX - e.touches[1].clientX;
                    let dy = e.touches[0].clientY - e.touches[1].clientY;
                    
                    const currentDist = Math.hypot(dx, dy);
                    if (initialPinchDist > 0) {
                        let newScale = startScale * (currentDist / initialPinchDist);
                        newScale = Math.max(0.3, Math.min(newScale, 2)); 
                        stateObj.scale = newScale;
                        scaleSliderEl.value = newScale;
                        document.getElementById(scaleValId).innerText = newScale.toFixed(1);
                    }

                    const currentAngle = Math.atan2(dy, dx) * (180 / Math.PI);
                    let angleDiff = currentAngle - initialPinchAngle;
                    let newRot = startRot + angleDiff;
                    
                    if (newRot > 180) newRot -= 360;
                    if (newRot < -180) newRot += 360;
                    
                    stateObj.rot = newRot;
                    rotSliderEl.value = newRot;
                    document.getElementById(rotValId).innerText = Math.round(newRot) + '°';

                    updateTransforms();
                }
            }, { passive: false });

            element.addEventListener('touchend', (e) => {
                if (e.touches.length < 2) {
                    checkMagneticSnap(idStr);
                }
            });
        }

        addMultiTouch(elABC, state.abc, sliderAbcScale, 'abc-scale-val', sliderAbcRot, 'abc-rot-val', 'abc');
        addMultiTouch(elEFG, state.efg, sliderEfgScale, 'efg-scale-val', sliderEfgRot, 'efg-rot-val', 'efg');

        document.getElementById('workspace').addEventListener('touchmove', (e) => {
            if (e.touches.length > 1) e.preventDefault();
        }, { passive: false });

        updateTransforms();
    </script>
</body>
</html>
